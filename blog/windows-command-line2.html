<!DOCTYPE html>
<!-- FilePath: blog/windows-command-line.html -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>cap10.tech: Windows Command Line: File System &amp; Navigation</title>
    <link rel="stylesheet" href="blog.css">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" sizes="16x16" href="/favicon-16x16.png">
    <link rel="icon" sizes="32x32" href="/favicon-32x32.png">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="icon" sizes="192x192" href="/android-chrome-192x192.png">
    <link rel="icon" sizes="512x512" href="/android-chrome-512x512.png">
    <link rel="manifest" href="/site.web-manifest">
</head>
<body>
<header class="site-header">
    <!-- Hamburger Menu Button -->
    <button id="hamburger-toggle" class="hamburger-toggle" aria-label="Open navigation menu" aria-controls="hamburger-menu" aria-expanded="false">
        <span class="hamburger-icon"></span>
    </button>
    <!-- Hamburger Menu Navigation (empty, populated by JS) -->
    <nav id="hamburger-menu" class="hamburger-menu" aria-label="Main Navigation" hidden>
        <ul></ul>
    </nav>
    <div class="header-branding">
        <a href="blogs.html" class="logo-link">
            <img src="/images/neon/neon-logbook.png" alt="Return to logbook library" class="header-logo"/>
        </a>
        <div class="header-text">
            <h1>Windows Command Line: File System &amp; Navigation</h1>
            <h3>The GUI is familiar, but the command line unlocks speed and power.</h3>
        </div>
    </div>
</header>
<main class="blog-content container">
    <!-- Introduction -->
    <section id="intro" class="highlight-box">
        <h2>Becoming a Cap10 of the Windows Command Line 🚀</h2>
        <blockquote>
            <p><strong>Objective:</strong> Teach absolute beginners how to confidently navigate, manage, and automate file system tasks in Windows using Command Prompt and PowerShell.</p>
        </blockquote>
        <hr>
        <h3>Launching Command Prompt &amp; PowerShell</h3>
        <p>To open <strong>Command Prompt</strong> (often called <code>cmd.exe</code>): press <kbd>Win + R</kbd>, type <code>cmd</code>, and hit <kbd>Enter</kbd>. To open <strong>PowerShell</strong>: press <kbd>Win + X</kbd> and select <strong>Windows PowerShell</strong> (or <strong>Windows PowerShell (Admin)</strong> for administrative tasks).</p>
        <pre><code>$ echo %CD%   # In Command Prompt, shows current directory
PS C:\Users\YourName> pwd   # In PowerShell, shows current location</code></pre>
        <p>Think of these shells as your helm for steering through Windows’ file system. You’ll use one or the other interchangeably, depending on your workflow and scripts.</p>
    </section>

    ```
    <!-- Table of Contents -->
    <nav class="table-of-contents highlight-box">
        <h2>Table of Contents</h2>
        <ul>
            <li><a href="#filesystem">1. Understanding the Windows File System</a></li>
            <li><a href="#navigation">2. Navigating the File System</a></li>
            <li><a href="#power-moves">3. Intermediate Command Line Power Moves</a></li>
            <li><a href="#final-challenge">4. Knowledge Check Challenge</a></li>
            <li><a href="#key-locations-tools">5. Key File Locations &amp; Tools</a></li>
            <li><a href="#advanced-file-systems">6. Advanced File System Mastery</a></li>
        </ul>
    </nav>

    <!-- Part 1 -->
    <section id="filesystem" class="highlight-box">
        <h2>1. Understanding the Windows File System</h2>
        <p>Before diving into commands, let’s map out how Windows organizes storage:</p>

        <h3>Key Concepts</h3>
        <ul>
            <li><strong>Drives (C:\, D:\, etc.):</strong> Windows assigns a letter to each storage volume—hard drives, SSDs, USB drives, even mapped network shares. The root of each drive is represented by that letter followed by <code>:\</code>.</li>
            <li><strong>Folders (Directories):</strong> Containers inside drives that organize files. Folders can nest to many levels—like folders within folders on your desktop—but accessed via paths.</li>
            <li><strong>Files:</strong> Individual items stored in folders—documents (<code>.txt</code>, <code>.docx</code>), executables (<code>.exe</code>), scripts (<code>.ps1</code>, <code>.bat</code>), images (<code>.png</code>), and more.</li>
            <li><strong>Paths:</strong> A file’s location in Windows is defined by its path, for example <code>C:\Users\YourName\Documents\report.txt</code>. Paths can be absolute (starting at the drive root) or relative (starting from the current folder).</li>
            <li><strong>Environment Variables:</strong> Shorthand tokens that expand to important directories. Examples include <code>%USERPROFILE%</code> (your user folder) and <code>%TEMP%</code> (temporary files folder). Using these makes scripts portable and concise.</li>
        </ul>

        <h3>Example Structure</h3>
        <pre><code>
```

C:
├── Program Files
├── Program Files (x86)
├── Windows
├── Users
│   └── YourName
│       ├── Desktop
│       ├── Documents
│       ├── Downloads
│       ├── Pictures
│       └── AppData
└── Temp </code></pre> <p>Within <code>C:\Users\YourName\</code>, you’ll find your personal folders and settings. The <code>AppData</code> folder is hidden by default and contains application-specific data (settings, caches, logs). System files reside under <code>C:\Windows</code>—tread carefully there.</p> <hr> </section>

    ```
    <!-- Part 2 -->
    <section id="navigation" class="highlight-box">
        <h2>2. Navigating the File System</h2>
        <p>Here are the core commands you’ll use to move around and manage files. We’ll show both Command Prompt (<code>cmd.exe</code>) and PowerShell equivalents.</p>

        <h3>2.1. Print Working Directory</h3>
        <p><strong>Command Prompt (CMD):</strong></p>
        <pre><code>echo %CD%</code></pre>
        <p><strong>PowerShell:</strong></p>
        <pre><code>pwd   # Or use $PWD to inspect properties</code></pre>
        <p>Use these to confirm where you are. In scripts, <code>%CD%</code> and <code>pwd</code> help you build relative paths and log actions.</p>

        <h3>2.2. List Files and Folders</h3>
        <p><strong>CMD:</strong></p>
        <pre><code>dir</code></pre>
        <p>Try <code>dir /w</code> for wide format or <code>dir /a</code> to include hidden and system files.</p>
        <p><strong>PowerShell:</strong></p>
        <pre><code>ls   # Alias for Get-ChildItem</code></pre>
        <p>Use <code>ls -Force</code> to see hidden files, and <code>ls -Recurse</code> to list subfolders, too.</p>

        <h3>2.3. Change Directory</h3>
        <p><strong>CMD &amp; PowerShell (shared syntax):</strong></p>
        <pre><code>cd C:\Users\YourName\Documents   # Move to Documents
```

cd ..                              # Up one level
cd \                               # Go to drive root</code></pre> <p>To switch drives in CMD, type <code>D:</code> or use <code>cd /d D:\Projects</code>. In PowerShell, <code>cd D:\Projects</code> also switches drives automatically. You can use <code>Set-Location</code> (alias <code>sl</code>) for clarity:</p> <pre><code>Set-Location C:\Users\YourName</code></pre>

        ```
        <h3>2.4. Create a New Folder</h3>
        <p><strong>CMD:</strong></p>
        <pre><code>mkdir MyFolder</code></pre>
        <p><strong>PowerShell:</strong></p>
        <pre><code>mkdir MyFolder   # Alias for New-Item -ItemType Directory
```

New-Item MyFolder -ItemType Directory</code></pre> <p>Use these to organize projects and documents quickly. Create nested folders with <code>mkdir ParentFolder\ChildFolder</code>—Windows will create both at once.</p>

        ```
        <h3>2.5. Create an Empty File</h3>
        <p><strong>PowerShell:</strong></p>
        <pre><code>New-Item myfile.txt -ItemType File</code></pre>
        <p><strong>CMD:</strong></p>
        <pre><code>type NUL &gt; myfile.txt</code></pre>
        <p>Or echo something into it:</p>
        <pre><code>echo Hello > myfile.txt</code></pre>
        <p>Use file creation to test scripts or generate placeholders. In PowerShell, <code>ni</code> is shorthand for <code>New-Item</code>.</p>

        <h3>2.6. Delete Files and Folders</h3>
        <p><strong>CMD:</strong></p>
        <pre><code>del myfile.txt           # Delete a file
```

rmdir MyFolder             # Remove an empty folder
rmdir /s /q MyFolder       # Remove folder and contents quietly </code></pre> <p><strong>PowerShell:</strong></p> <pre><code>Remove-Item myfile.txt            # Delete a file
Remove-Item MyFolder -Recurse           # Delete folder and contents
Remove-Item MyFolder -Recurse -Force     # Force deletion, including read-only</code></pre> <p>Be cautious—<code>del</code> and <code>Remove-Item</code> don’t send items to Recycle Bin by default. Use <code>shell\:RecycleBinFolder</code> in File Explorer to recover mistakenly deleted items, but in scripts, assume deletion is permanent.</p>

        ```
        <h3>2.7. Copy and Move Files</h3>
        <p><strong>CMD:</strong></p>
        <pre><code>copy myfile.txt C:\Backup\        # Copy a file
```

move myfile.txt C:\Backup\        # Move (or rename) a file
xcopy C:\Docs\* C:\Backup\Docs\ /E /I   # Copy directories with subfolders (/E) and assume destination is folder (/I) </code></pre> <p><strong>PowerShell:</strong></p> <pre><code>Copy-Item myfile.txt C:\Backup\         # Copy a file
Move-Item myfile.txt C:\Backup\         # Move or rename
Copy-Item C:\Docs\* C:\Backup\Docs\ -Recurse    # Copy directory and all subitems </code></pre> <p><strong>When to use:</strong> Use <code>xcopy</code> for legacy scripts or <code>robocopy</code> (more on that later) for robust directory duplication. In PowerShell, <code>Copy-Item</code> and <code>Move-Item</code> integrate with objects, letting you filter and pipe results.</p> <hr> </section>

    ```
    <!-- Part 3 -->
    <section id="power-moves" class="highlight-box">
        <h2>3. Intermediate Command Line Power Moves</h2>
        <p>Once you have the basics down, it’s time to harness the command line’s advanced capabilities. These power moves will make you more efficient and set the foundation for scripting and automation.</p>

        <h3>3.1. Chaining Commands</h3>
        <p>In CMD, use <code>&amp;&amp;</code> to run the next command only if the first succeeds:</p>
        <pre><code>mkdir TestFolder && cd TestFolder</code></pre>
        <p>In PowerShell, the semicolon <code>;</code> separates commands, but to stop on failure, use <code> -and</code> or <code>if</code> logic:</p>
        <pre><code>New-Item TestFolder -ItemType Directory; Set-Location TestFolder</code></pre>
        <p>Or for conditional:</p>
        <pre><code>if (New-Item TestFolder -ItemType Directory) { Set-Location TestFolder }</code></pre>

        <h3>3.2. Piping and Filters</h3>
        <p><strong>CMD:</strong> Use <code>|</code> to pipe output. For example:</p>
        <pre><code>dir /b | findstr ".txt"</code></pre>
        <p>This lists only <code>.txt</code> files in the current directory. <code>/b</code> yields bare format (filenames only).</p>
        <p><strong>PowerShell:</strong> Piping is more powerful because it passes objects rather than plain text. Example:</p>
        <pre><code>Get-ChildItem -Recurse | Where-Object { $_.Extension -eq ".txt" }</code></pre>
        <p>This searches all subfolders for <code>.txt</code> files. <code>$_</code> represents each file object, letting you inspect properties (size, last write time, etc.).</p>

        <h3>3.3. History and Autocomplete</h3>
        <ul>
            <li><strong>CMD:</strong> Use <kbd>F7</kbd> to display command history; <kbd>F8</kbd> cycles through previous commands that match your current input.</li>
            <li><strong>PowerShell:</strong> Use the Up/Down arrows to scroll through history. Press <kbd>Ctrl + R</kbd> to perform a reverse search through previous entries—type part of a command to locate it quickly.</li>
        </ul>
        <p>Use these to avoid retyping long commands. In PowerShell, <code>Get-History</code> shows all past commands in the session.</p>

        <h3>3.4. Aliases and Profiles</h3>
        <p><strong>PowerShell:</strong> You can define aliases in your profile so common commands are shorter. Edit your profile with:</p>
        <pre><code>notepad $PROFILE</code></pre>
        <p>Add lines like:</p>
        <pre><code>Set-Alias ll Get-ChildItem
```

Set-Alias rm Remove-Item
Set-Alias cp Copy-Item</code></pre> <p>Save and restart PowerShell. Now <code>ll</code> lists files, <code>rm</code> deletes items, etc. Profiles load at startup—customize them to suit your workflow.</p>

        ```
        <h3>3.5. Manual Pages and Help</h3>
        <p><strong>CMD:</strong> Use <code>command /?</code> to display help for any built-in command:</p>
        <pre><code>dir /?</code></pre>
        <p><strong>PowerShell:</strong> Use <code>Get-Help</code> for detailed documentation, including examples:</p>
        <pre><code>Get-Help Copy-Item -Full</code></pre>
        <p>To update the local help content (first run may take a few minutes):</p>
        <pre><code>Update-Help</code></pre>
        <p>Help topics include syntax, parameter explanations, and usage examples—treat them as your captain’s manual.</p>

        <h3>3.6. Developer Tools (Sneak Peek)</h3>
        <ul>
            <li><strong>Chocolatey (CMD/PowerShell):</strong> Windows package manager. Install it via PowerShell (in an elevated shell):</li>
            <pre><code>Set-ExecutionPolicy Bypass -Scope Process -Force; `
```

\[System.Net.ServicePointManager]::SecurityProtocol = `[System.Net.ServicePointManager]::SecurityProtocol -bor 3072;`
iex ((New-Object System.Net.WebClient).DownloadString('[https://community.chocolatey.org/install.ps1](https://community.chocolatey.org/install.ps1)'))</code></pre> <p>Then install packages like <code>choco install git</code>, <code>choco install python</code>.</p> <li><strong>Git:</strong> After installing, verify with <code>git --version</code>. Use <code>git clone</code>, <code>git status</code>, and other Git commands from either shell.</li> <li><strong>Node.js & nvm-windows:</strong> Install nvm for Windows (<code>nvm-windows</code>) to manage Node versions. Then use <code>nvm install 14</code>, <code>nvm use 14</code>.</li> <li><strong>VS Code CLI:</strong> If Visual Studio Code is installed, use <code>code .</code> in PowerShell or CMD to open the current folder in VS Code.</li> </ul> <hr> </section>

    ```
    <!-- Part 4 -->
    <section id="final-challenge" class="highlight-box">
        <h2>4. Knowledge Check Challenge: Prove Your Command Line Captaincy</h2>
        <ul>
            <li><strong>Create</strong> a new folder called <code>Projects</code> inside <code>%USERPROFILE%\Documents</code> (e.g., <code>cd %USERPROFILE%\Documents &amp;&amp; mkdir Projects</code>).</li>
            <li><strong>Create</strong> a file called <code>readme.txt</code> inside <code>Projects</code> and write “Hello, Cap10!” into it (<code>echo Hello, Cap10! &gt; %USERPROFILE%\Documents\Projects\readme.txt</code> or PowerShell’s <code>"Hello, Cap10!" | Out-File $HOME\Documents\Projects\readme.txt</code>).</li>
            <li><strong>Rename</strong> it to <code>info.txt</code> (<code>ren %USERPROFILE%\Documents\Projects\readme.txt info.txt</code> or <code>Rename-Item $HOME\Documents\Projects\readme.txt info.txt</code>).</li>
            <li><strong>Move</strong> <code>info.txt</code> to the <code>Desktop</code> (<code>move %USERPROFILE%\Documents\Projects\info.txt %USERPROFILE%\Desktop\</code> or <code>Move-Item $HOME\Documents\Projects\info.txt $HOME\Desktop\</code>).</li>
            <li><strong>Delete</strong> <code>info.txt</code> from the <code>Desktop</code> (<code>del %USERPROFILE%\Desktop\info.txt</code> or <code>Remove-Item $HOME\Desktop\info.txt</code>).</li>
            <li><strong>List</strong> all <code>.txt</code> files in your <code>%USERPROFILE%\Documents\</code> folder (<code>dir %USERPROFILE%\Documents\*.txt</code> or <code>ls $HOME\Documents\*.txt</code>).</li>
        </ul>
        <p>Master these, and you’re officially a Cap10 of the Windows command line! 🏴‍☠️ Would you like a <strong>cheat sheet</strong> with all these commands for quick reference? 🚀</p>
    </section>

    <!-- Part 5 -->
    <section id="key-locations-tools" class="highlight-box">
        <h2>5. Key File Locations &amp; Tools Available in the CLI</h2>
        <p>Here’s a treasure map of important directories and utilities you’ll frequently interact with in Windows’ command line:</p>

        <h3>5.1 Common Directories</h3>
        <ul>
            <li><strong><code>C:\</code>:</strong> The root directory of your primary system volume. Inside you’ll find:</li>
            <ul>
                <li><code>Program Files</code> and <code>Program Files (x86)</code>: Installed applications. 64-bit apps go under <code>C:\Program Files</code>, while 32-bit apps reside in <code>C:\Program Files (x86)</code>.</li>
                <li><code>Windows</code>: OS files—alter only if you know exactly what you’re doing.</li>
                <li><code>Users</code>: Each user has a subfolder (<code>C:\Users\YourName</code>) containing personal data.</li>
            </ul>
            <li><strong><code>C:\Users\YourName\</code>:</strong> Your personal user directory—home to your documents, desktop, downloads, and hidden <code>AppData</code> folder.</li>
            <li><strong><code>C:\ProgramData\</code>:</strong> Stores data shared among all users—application settings, database files, and global configurations. Hidden by default.</li>
            <li><strong><code>%USERPROFILE%\AppData\Local\</code>:</strong> Local application data—caches, logs, and settings for each user. Clear temp files here when troubleshooting.</li>
            <li><strong><code>%USERPROFILE%\AppData\Roaming\</code>:</strong> Roaming profiles—settings that sync if using a domain account.</li>
            <li><strong><code>%TEMP%</code> or <code>%USERPROFILE%\AppData\Local\Temp\</code>:</strong> Temporary files—safe to clear regularly if you need disk space.</li>
            <li><strong><code>C:\Temp\</code>:</strong> Another common location for temp files used by scripts or installers—check this if cleaning up leftover artifacts.</li>
        </ul>

        <h3>5.2 Essential Command Line Tools</h3>
        <ul>
            <li><strong><code>dir</code> (CMD):</strong> Lists directory contents. Options include <code>/s</code> to recurse, <code>/b</code> for bare format.</li>
            <li><strong><code>cd</code> / <code>Set-Location</code>:</strong> Change directory. In PowerShell, <code>Set-Location</code> and <code>sl</code> are built-in cmdlets with additional features.</li>
            <li><strong><code>mkdir</code> / <code>New-Item -ItemType Directory</code>:</strong> Create a folder. Use nested paths to create multiple levels at once.</li>
            <li><strong><code>del</code> / <code>Remove-Item</code>:</strong> Remove files or folders. In PowerShell, <code>-Recurse</code> and <code>-Force</code> handle subfolders and read-only files.</li>
            <li><strong><code>copy</code> / <code>Copy-Item</code>:</strong> Copy files. Use <code>xcopy</code> or <code>robocopy</code> (PowerShell’s <code>Copy-Item</code> does recursive copying with <code>-Recurse</code>).</li>
            <li><strong><code>move</code> / <code>Move-Item</code>:</strong> Move or rename files. Use <code>Move-Item -Force</code> to overwrite.</li>
            <li><strong><code>xcopy</code>:</strong> Legacy utility for copying entire directories with options (<code>/E</code>, <code>/I</code>, <code>/Y</code>).</li>
            <li><strong><code>robocopy</code>:</strong> Robust file copy utility. Use <code>robocopy C:\Source C:\Dest /MIR /Z /R:3 /W:5</code> to mirror a directory, retry on failure, and resume partial copies.</li>
            <li><strong><code>findstr</code> / <code>Select-String</code>:</strong> Search text within files. <code>findstr /S /I "error" *.log</code> searches all <code>.log</code> files recursively, ignoring case. In PowerShell: <code>Select-String -Path *.log -Pattern "error"</code>.</li>
            <li><strong><code>tasklist</code>:</strong> Lists running processes. Use <code>tasklist /FI "IMAGENAME eq notepad.exe"</code> to filter by process name.</li>
            <li><strong><code>taskkill</code>:</strong> Terminates processes. Example: <code>taskkill /IM notepad.exe /F</code> forcefully kills Notepad.</li>
            <li><strong><code>wmic</code>:</strong> Query system information. Example: <code>wmic logicaldisk get size,freespace,caption</code> to view drive capacities.</li>
            <li><strong><code>choco</code>:</strong> Chocolatey package manager. Install or update apps with <code>choco install git</code>, <code>choco upgrade python</code>.</li>
            <li><strong><code>Get-PSDrive</code>:</strong> PowerShell cmdlet to list all drives (C:, D:, network shares, even registry hives can appear as drives).</li>
            <li><strong><code>Get-ChildItem</code> (<code>ls</code>):</strong> PowerShell cmdlet to list directory contents; use <code>-Recurse</code> to walk subfolders.</li>
            <li><strong><code>Get-EventLog</code>:</strong> Inspect system and application logs. Example: <code>Get-EventLog -LogName Application -Newest 50</code> shows the 50 most recent entries.</li>
        </ul>

        <h3>5.3 Environment Variables</h3>
        <p>Environment variables let you reference key paths without hardcoding them. Use <code>echo %VARIABLE%</code> in CMD or <code>$Env:VARIABLE</code> in PowerShell to inspect them.</p>
        <ul>
            <li><strong><code>%USERPROFILE%</code> / <code>$Env:USERPROFILE</code>:</strong> Your home directory (e.g., <code>C:\Users\YourName</code>).</li>
            <li><strong><code>%APPDATA%</code> / <code>$Env:APPDATA</code>:</strong> Roaming application data (<code>C:\Users\YourName\AppData\Roaming</code>).</li>
            <li><strong><code>%LOCALAPPDATA%</code> / <code>$Env:LOCALAPPDATA</code>:</strong> Local application data (<code>C:\Users\YourName\AppData\Local</code>).</li>
            <li><strong><code>%TEMP%</code> / <code>$Env:TEMP</code>:</strong> Temporary files folder. Use <code>cd %TEMP%</code> or <code>cd $Env:TEMP</code> to navigate there and clear junk.</li>
            <li><strong><code>%PROGRAMFILES%</code> / <code>$Env:PROGRAMFILES</code>:</strong> Default folder for installed programs (<code>C:\Program Files</code>).</li>
            <li><strong><code>%WINDIR%</code> / <code>$Env:WINDIR</code>:</strong> Windows system folder (<code>C:\Windows</code>).</li>
        </ul>
        <p>Using environment variables makes your scripts resilient—if a user’s profile is on <code>D:\Users</code> instead of <code>C:\Users</code>, <code>%USERPROFILE%</code> still resolves correctly.</p>
    </section>

    <!-- Part 6 -->
    <section id="advanced-file-systems" class="highlight-box blog-content" aria-labelledby="advanced-file-systems-title">
        <h2 id="advanced-file-systems-title">6. Advanced File System Mastery</h2>
        <h3>Expanding Your Command-Line Horizons</h3>
        <p>In this section, we’ll ground each command in real-world scenarios—exploring permissions, links, searching tools, disk usage, mounting network shares, scripting, and system monitoring. By understanding not just <em>what</em> to run but <em>why</em>, you’ll steer your Windows environment with confidence.</p>

        <h4>Filesystem Permissions &amp; Ownership</h4>
        <ul>
            <li>
                <strong>Concept:</strong> Windows uses Access Control Lists (ACLs) to manage permissions. Each file and folder has an owner and a set of ACEs (Access Control Entries) specifying which users/groups can read, write, or execute. Permissions override inheritance when explicitly set.
            </li>
            <li>
                <strong>When to Use:</strong> If you cannot open, modify, or delete a file or folder, inspect and adjust ACLs. For shared folders, grant specific users access without exposing everything.
            </li>
            <li>
                <strong>Inspecting Permissions:</strong> In PowerShell, use <code>Get-Acl</code>:</li>
            <pre><code class="language-powershell">
```

Get-Acl C:\Projects\Secret.txt | Format-List</code></pre> <p>This shows the owner and all ACEs (e.g., <code>BUILTIN\Administrators Allow  FullControl</code>). In CMD, use <code>icacls</code>:</p> <pre><code class="language-bash">
icacls "C:\Projects\Secret.txt"</code></pre> <p>This outputs a list of users/groups and their permissions (R, W, M, F, etc.).</p> <li> <strong>Changing Ownership:</strong> Use <code>takeown</code> or <code>icacls</code>. Example:</li> <pre><code class="language-bash">
takeown /F "C:\Projects\Secret.txt"</code></pre> <p>This makes the current user the owner. Then grant yourself full control:</p> <pre><code class="language-bash">
icacls "C:\Projects\Secret.txt" /grant YourName\:F</code></pre> <p>In PowerShell, you can pipe ACE modifications:</p> <pre><code class="language-powershell">
\$acl = Get-Acl C:\Projects\Secret.txt
\$rule = New-Object System.Security.AccessControl.FileSystemAccessRule("YourName","FullControl","Allow")
\$acl.AddAccessRule(\$rule)
Set-Acl C:\Projects\Secret.txt \$acl</code></pre> <p>This programmatically adds a rule for <code>YourName</code> to have full control.</p> <li> <strong>Removing Permissions:</strong> In CMD:</li> <pre><code class="language-bash">
icacls "C:\Projects\Secret.txt" /remove Guest</code></pre> <p>In PowerShell:</p> <pre><code class="language-powershell">
\$acl = Get-Acl C:\Projects\Secret.txt
\$acl.Access | Where-Object { \$*.IdentityReference -eq "Guest" } | ForEach-Object { \$acl.RemoveAccessRule(\$*) }
Set-Acl C:\Projects\Secret.txt \$acl</code></pre> <p>Always verify with <code>Get-Acl</code> or <code>icacls</code> after changes. Improper modifications can lock you out.</p> </ul>

        ```
        <h4>Symbolic and Hard Links</h4>
        <ul>
            <li>
                <strong>Concept:</strong> Windows supports symbolic links (symlinks), hard links, and junctions. Symlinks point to files or directories on any drive. Hard links make two directory entries refer to the same physical file on the same volume. Junctions act like directory symlinks limited to local volumes.
            </li>
            <li>
                <strong>When to Use:</strong> Symlinks let you present a file or folder at multiple virtual locations without copying data. Hard links save space when you need multiple directory entries for the same file. Junctions are useful when tools expect a specific path structure.
            </li>
            <li>
                <strong>Creating a Symlink:</strong> Use <code>mklink</code> in an elevated CMD or PowerShell (run as Administrator):</li>
            <pre><code class="language-bash">
```

mklink "C:\Projects\Latest" "C:\Builds\Version2025"</code></pre> <p>This creates a folder symlink <code>Latest</code> that points to <code>C:\Builds\Version2025</code>. If you cd into <code>C:\Projects\Latest</code>, you’re actually in <code>Version2025</code>.</p> <li> <strong>Creating a File Hard Link:</strong></li> <pre><code class="language-bash">
mklink /H "C:\Projects\SpecRef.docx" "D:\Specs\SpecRef.docx"</code></pre> <p>Both <code>SpecRef.docx</code> entries now refer to the same data on disk. Editing one updates the other. Only volumes that support NTFS can host hard links, and they must be on the same volume.</p> <li> <strong>Creating a Junction:</strong> For directories on the same drive:</li> <pre><code class="language-bash">
mklink /J "C:\Projects\LegacyDocs" "D:\OldVersions\Docs"</code></pre> <p>This makes <code>LegacyDocs</code> a junction to <code>D:\OldVersions\Docs</code>, visible to both CMD and PowerShell.</p> <li> <strong>Inspecting Links:</strong> Use <code>dir</code>—symlinks appear with <code>\<SYMLINK></code> or <code>\<JUNCTION></code>. To find where a symlink points:</li> <pre><code class="language-powershell">
Get-Item "C:\Projects\Latest" | Format-List -Property Target</code></pre> <p>In CMD, <code>dir</code> shows the arrow <code>\[-> path]</code> after symlink names.</p> </ul>

        ```
        <h4>Search and Locate Tools</h4>
        <ul>
            <li>
                <strong>Concept:</strong> When you need to find files by name, content, or metadata, Windows offers built-in tools (<code>dir /s</code>, <code>where</code>, <code>findstr</code>) and PowerShell cmdlets (<code>Get-ChildItem</code>, <code>Select-String</code>).
            </li>
            <li>
                <strong>When to Use:</strong> If you remember only part of a filename or must locate files containing a keyword, these commands save significant time—especially across large projects.
            </li>
            <li>
                <strong>Find Files by Name:</strong> In CMD:</li>
            <pre><code class="language-bash">
```

dir C:\Projects\*.log /S /B</code></pre> <p><code>/S</code> recurses subfolders; <code>/B</code> yields bare paths. Or use <code>where</code> for executables in <code>%PATH%</code>:</p> <pre><code class="language-bash">
where git.exe</code></pre> <li> <strong>PowerShell Get-ChildItem:</strong> To search by name:</li> <pre><code class="language-powershell">
Get-ChildItem -Path C:\Projects -Filter *.log -Recurse</code></pre> <p>Use <code>-Include</code> and <code>-Exclude</code> for more complex filters:</p> <pre><code class="language-powershell">
Get-ChildItem C:\Projects -Recurse -Include "*.log","*.txt" -Exclude "*.bak"</code></pre> <li> <strong>Search File Contents:</strong> In CMD:</li> <pre><code class="language-bash">
findstr /S /I "ERROR" C:\Projects\*.log</code></pre> <p><code>/S</code> searches subfolders; <code>/I</code> ignores case. In PowerShell:</p> <pre><code class="language-powershell">
Select-String -Path C:\Projects\*.log -Pattern "ERROR" -CaseSensitive:\$false</code></pre> <p>Get match details including file path, line number, and matched text—ideal for debugging or auditing logs.</p> <li> <strong>Locate Using Index:</strong> To search Windows Search index from PowerShell, use <code>Get-ChildItem -Path C:\Users\YourName\Documents -Recurse</code> with <code>-Filter</code> for indexed properties, or leverage <code>Search-UnifiedAuditLog</code> for enterprise audit logs. For everyday use, <code>Get-ChildItem</code> suffices.</li> </ul>

        ```
        <h4>Disk Usage and Free Space Tracking</h4>
        <ul>
            <li>
                <strong>Concept:</strong> Knowing how much disk space a folder consumes helps you clean up large projects or temporary files. Windows doesn’t include <code>du</code> by default, but you can use PowerShell’s <code>Get-ChildItem</code> with calculated properties or Sysinternals’ <code>du.exe</code>.
            </li>
            <li>
                <strong>When to Use:</strong> When your system notifies you of low disk space, these commands identify space hogs so you know exactly what to archive or delete.
            </li>
            <li>
                <strong>PowerShell Folder Size:</strong> Summarize a directory’s total size:</li>
            <pre><code class="language-powershell">
```

(Get-ChildItem C:\Projects -Recurse | Measure-Object -Property Length -Sum).Sum / 1GB</code></pre> <p>This outputs the size in gigabytes. To list sizes of first-level subfolders:</p> <pre><code class="language-powershell">
Get-ChildItem C:\Projects | Where-Object { \$*.PSIsContainer } | ForEach-Object {
\$size = (Get-ChildItem \$*.FullName -Recurse | Measure-Object Length -Sum).Sum
\[PSCustomObject]@{ Folder = \$*.Name; SizeGB = \[math]::Round(\$size /1GB, 2) }
} | Sort-Object SizeGB -Descending | Format-Table -AutoSize</code></pre> <p>This outputs a table with folder names and sizes, sorted by largest first. Use it to spot resource-heavy directories (for example, <code>Videos</code> or <code>Node\_modules</code>).</p> <li> <strong>Sysinternals du.exe:</strong> Download from Microsoft Sysinternals, extract to a folder in <code>%PATH%</code>, then:</li> <pre><code class="language-bash">
du -q -l 1 C:\Projects</code></pre> <p><code>-q</code> shows quiet output with summary, <code>-l 1</code> limits depth to one level. This quickly lists the sizes of each subfolder without scripting.</p> <li> <strong>Check Drive Free Space:</strong> In CMD:</li> <pre><code class="language-bash">
wmic logicaldisk get caption, freespace, size</code></pre> <p>In PowerShell:</p> <pre><code class="language-powershell">
Get-PSDrive -PSProvider FileSystem | Select-Object Name, @{Name="Used(GB)";Expression={\[math]::Round((\$*.Used/1GB),2)}}, @{Name="Free(GB)";Expression={\[math]::Round(($\_.Free/1GB),2)}}</code></pre> <p>This yields a list of drives with used and free space as gigabytes—handy for monitoring partitions, USB drives, or network-mapped drives.</p> </ul>

        ```
        <h4>Mounting, Unmounting, and Network Shares</h4>
        <ul>
            <li>
                <strong>Concept:</strong> In Windows, network shares (SMB/CIFS) let you map remote folders as local drives. You can connect, disconnect, and manage them from the command line. Additionally, “mounting” virtual disks (<code>.vhd</code>, <code>.iso</code>) attaches them as new drives.
            </li>
            <li>
                <strong>When to Use:</strong> When collaborating on shared resources or backing up files to a NAS, mapping a network location streamlines file access. Mounting a VHD or ISO lets you browse its contents without GUI steps.
            </li>
            <li>
                <strong>Map a Network Drive:</strong> In CMD or PowerShell:</li>
            <pre><code class="language-bash">
```

net use Z: \fileserver\SharedDocs /persistent\:yes</code></pre> <p>This maps the shared folder <code>\fileserver\SharedDocs</code> to drive <code>Z:</code>, reconnecting on login (<code>/persistent\:yes</code>).</p> <li> <strong>Disconnect a Mapped Drive:</strong></li> <pre><code class="language-bash">
net use Z: /delete</code></pre> <li> <strong>Mount a VHD:</strong> In PowerShell (run as Administrator):</li> <pre><code class="language-powershell">
Mount-DiskImage -ImagePath "C:\Backups\Archive.vhd"</code></pre> <p>After mounting, Windows assigns a drive letter. To unmount:</p> <pre><code class="language-powershell">
Dismount-DiskImage -ImagePath "C:\Backups\Archive.vhd"</code></pre> <li> <strong>Use DiskPart for Advanced Mounts:</strong> In an elevated CMD:</li> <pre><code class="language-bash">
diskpart
DISKPART> select vdisk file="C:\Backups\Archive.vhd"
DISKPART> attach vdisk </code></pre> <p>Once the VHD is attached, it appears as a new drive. When done, use:</p> <pre><code class="language-bash">
DISKPART> detach vdisk
DISKPART> exit </code></pre> </ul>

        ```
        <h4>Permissions in Action: UAC &amp; Elevated Tasks</h4>
        <ul>
            <li>
                <strong>Concept:</strong> User Account Control (UAC) limits administrative privileges. Certain file system locations—<code>C:\Windows</code>, <code>C:\Program Files</code>—require elevated rights to modify. The command line must run as Administrator to change these.
            </li>
            <li>
                <strong>When to Use:</strong> When scripts install software, modify <code>hosts</code> file, or adjust system-wide settings, run your shell elevated. Changes to protected folders without elevation fail with “Access Denied.”
            </li>
            <li>
                <strong>Open Elevated PowerShell:</strong> Press <kbd>Win + X</kbd> and choose <strong>Windows PowerShell (Admin)</strong>. You’ll see “Administrator” in the title bar. Confirm any prompts.
            </li>
            <li>
                <strong>Edit <code>hosts</code> File:</strong> The hosts file lives in <code>C:\Windows\System32\drivers\etc\hosts</code>. To edit in Notepad with elevation:</li>
            <pre><code class="language-powershell">
```

Start-Process notepad.exe -Verb RunAs -ArgumentList "C:\Windows\System32\drivers\etc\hosts"</code></pre> <p>This launches Notepad as Administrator, letting you save changes. In CMD, use:</p> <pre><code class="language-bash">
runas /user\:Administrator "notepad C:\Windows\System32\drivers\etc\hosts"</code></pre> <p>Alternatively, use PowerShell’s <code>Set-Content</code> to append entries:</p> <pre><code class="language-powershell">
"127.0.0.1 example.com" | Out-File -FilePath "C:\Windows\System32\drivers\etc\hosts" -Append</code></pre> </ul>

        ```
        <h4>Archive and Compression Tools</h4>
        <ul>
            <li>
                <strong>Concept:</strong> Compressing files reduces size for storage or sharing. Windows includes <code>Compress-Archive</code> and <code>Expand-Archive</code> in PowerShell. Sysinternals offers <code>7zip</code> integration, but built-in tools work for most use cases.
            </li>
            <li>
                <strong>When to Use:</strong> When sending large folders over email, backing up logs, or archiving projects, compressing saves space and bandwidth.
            </li>
            <li>
                <strong>Create a ZIP Archive (PowerShell):</strong></li>
            <pre><code class="language-powershell">
```

Compress-Archive -Path C:\Projects\* -DestinationPath C:\Backups\ProjectsArchive.zip</code></pre> <p>This zips all contents of <code>C:\Projects</code> into <code>ProjectsArchive.zip</code>. Use <code>-Update</code> to add or replace items.</p> <li> <strong>Extract a ZIP Archive:</strong></li> <pre><code class="language-powershell">
Expand-Archive -Path C:\Backups\ProjectsArchive.zip -DestinationPath C:\RestoredProjects</code></pre> <li> <strong>Compress a Single File:</strong> In PowerShell:</li> <pre><code class="language-powershell">
Compress-Archive -LiteralPath C:\Logs\error.log -DestinationPath C:\Logs\error.log.zip</code></pre> <p>Alternatively, if you have 7-Zip installed and added to <code>%PATH%</code>, you can run:</p> <pre><code class="language-bash">
7z a C:\Logs\error.7z C:\Logs\error.log</code></pre> <p>This uses LZMA compression, often achieving better ratios than ZIP.</p> </ul>

        ```
        <h4>Searching the Registry from CLI</h4>
        <ul>
            <li>
                <strong>Concept:</strong> The Windows Registry stores configuration for the OS and applications. Use <code>reg</code> commands in CMD or <code>Get-ItemProperty</code> in PowerShell to query, export, or modify registry keys.
            </li>
            <li>
                <strong>When to Use:</strong> When troubleshooting application behavior, enabling hidden features, or scripting environment setup, registry edits can be automated from the command line.
            </li>
            <li>
                <strong>View a Registry Key:</strong> In CMD:</li>
            <pre><code class="language-bash">
```

reg query "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced" /v Hidden</code></pre> <p>This retrieves the value of <code>Hidden</code> under Advanced Explorer settings.</p> <li> <strong>Modify a Registry Value:</strong> In CMD:</li> <pre><code class="language-bash">
reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced" /v Hidden /t REG\_DWORD /d 1 /f</code></pre> <p><code>/v</code> specifies the value name, <code>/t</code> the type, <code>/d</code> the data, and <code>/f</code> forces overwrite without prompt. In PowerShell:</p> <pre><code class="language-powershell">
Set-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced" -Name Hidden -Type DWord -Value 1</code></pre> <p>This toggles showing hidden files in File Explorer. Use <code>Get-ItemProperty</code> to retrieve values:</p> <pre><code class="language-powershell">
Get-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced" -Name Hidden</code></pre> </ul>

        ```
        <h4>Disk and Filesystem Health Monitoring</h4>
        <ul>
            <li>
                <strong>Concept:</strong> Over time, disks can develop errors or bad sectors. Use <code>chkdsk</code> to check and repair file system issues. Windows also uses S.M.A.R.T. (Self-Monitoring, Analysis and Reporting Technology) to predict hardware failures.
            </li>
            <li>
                <strong>When to Use:</strong> When you get I/O errors or suspect disk corruption, run these tools before data loss becomes catastrophic.
            </li>
            <li>
                <strong>Check Disk (CHKDSK):</strong> In an elevated CMD:</li>
            <pre><code class="language-bash">
```

chkdsk C: /F /R</code></pre> <p><code>/F</code> fixes errors, <code>/R</code> locates bad sectors and recovers readable data. If you’re checking the system drive, you’ll be prompted to schedule this at next reboot.</p> <li> <strong>View S.M.A.R.T. Attributes:</strong> Windows doesn’t include a built-in CLI for S.M.A.R.T. data, but PowerShell’s <code>Get-PhysicalDisk</code> (on newer versions) or <code>Get-WmiObject</code> can retrieve some info:</li> <pre><code class="language-powershell">
Get-PhysicalDisk | Select-Object FriendlyName, OperationalStatus, HealthStatus</code></pre> <p>For deeper S.M.A.R.T. details, install <code>smartmontools</code> or use a GUI utility. If many attributes indicate pre-fail, back up your data immediately.</p> </ul>

        ```
        <h4>Environment Management: PowerShell Profiles &amp; Modules</h4>
        <ul>
            <li>
                <strong>Concept:</strong> PowerShell profiles let you load custom functions, aliases, and modules at startup. Modules are collections of cmdlets, functions, and scripts packaged for reuse.
            </li>
            <li>
                <strong>When to Use:</strong> For a consistent environment across machines, store your favorite functions (e.g., <code>Get-DiskSpace</code>) in your profile. Load modules like <code>PSReadLine</code> for enhanced command editing.
            </li>
            <li>
                <strong>Edit Your Profile:</strong> In PowerShell:</li>
            <pre><code class="language-powershell">
```

if (!(Test-Path -Path \$PROFILE)) { New-Item -ItemType File -Path \$PROFILE -Force }
notepad \$PROFILE</code></pre> <p>Add functions or import modules:</p> <pre><code class="language-powershell">
Import-Module PSReadLine
Set-Alias gs Get-ChildItem
function Get-DiskSpace {
Get-PSDrive -PSProvider FileSystem | Select-Object Name, @{n="Free(GB)";e={\[math]::Round($\_.Free/1GB,2)}}
}</code></pre> <li> <strong>Installing Modules:</strong> From PowerShell Gallery:</li> <pre><code class="language-powershell">
Install-Module -Name PowerShellGet -Force
Install-Module -Name Pester -Scope CurrentUser</code></pre> <p>The <code>Pester</code> module helps with script testing. Use <code>Find-Module</code> to search for packages (e.g., <code>Find-Module -Name "*Azure*"</code>).</p> </ul>

        ```
        <h4>Security and Privacy Considerations</h4>
        <ul>
            <li>
                <strong>Concept:</strong> The Windows Firewall controls inbound and outbound network traffic. You can enable, configure rules, and whitelist apps from the CLI. Group Policy (via <code>gpedit.msc</code>) also can be manipulated with commands for enterprise environments.
            </li>
            <li>
                <strong>When to Use:</strong> When securing a server or remote machine, script firewall rules to open specific ports or block unwanted traffic.
            </li>
            <li>
                <strong>Enable Windows Firewall:</strong> In an elevated CMD or PowerShell:</li>
            <pre><code class="language-bash">
```

netsh advfirewall set allprofiles state on</code></pre> <li> <strong>Allow an App Through Firewall:</strong> In PowerShell:</li> <pre><code class="language-powershell">
New-NetFirewallRule -DisplayName "Allow SSH" -Direction Inbound -Program "C:\Windows\System32\OpenSSH\sshd.exe" -Action Allow</code></pre> <p>This allows inbound SSH traffic if you have OpenSSH installed. To remove a rule:</p> <pre><code class="language-powershell">
Remove-NetFirewallRule -DisplayName "Allow SSH"</code></pre> <li> <strong>BitLocker Drive Encryption:</strong> Manage BitLocker from CLI to secure data at rest. Example: encrypt the C: drive:</li> <pre><code class="language-bash">
manage-bde -on C: -RecoveryPassword</code></pre> <p>This turns on BitLocker and generates a recovery password (prompted by the command). Use <code>manage-bde -status</code> to check encryption state.</p> <li> <strong>Remove Quarantine Flag:</strong> Windows marks downloaded files with an alternate data stream <code>Zone.Identifier</code>. To remove:</li> <pre><code class="language-powershell">
Remove-Item -Path "C:\Downloads\newApp.exe\:Zone.Identifier"</code></pre> <p>This deletes the zone identifier, allowing the app to run without “blocked file” prompts.</p> </ul>

        ```
        <h4>Logging, Audit Trails, and System Reports</h4>
        <ul>
            <li>
                <strong>Concept:</strong> Windows Event Logs capture system, application, and security events. Use <code>Get-EventLog</code> or <code>Get-WinEvent</code> in PowerShell to query logs. <code>Systeminfo</code> and <code>Get-ComputerInfo</code> provide hardware and OS details.
            </li>
            <li>
                <strong>When to Use:</strong> If an application crashes, or hardware behaves unexpectedly, logs hold clues. Regularly archiving logs can aid troubleshooting.
            </li>
            <li>
                <strong>View Recent Application Events:</strong> In PowerShell:</li>
            <pre><code class="language-powershell">
```

Get-EventLog -LogName Application -Newest 50 | Format-Table TimeWritten, EntryType, Source, Message -AutoSize</code></pre> <p>This lists the 50 most recent entries in the Application log with timestamp, severity, source, and message.</p> <li> <strong>Filter Security Events:</strong> To see failed login attempts:</li> <pre><code class="language-powershell">
Get-WinEvent -FilterHashtable @{LogName='Security'; Id=4625} -MaxEvents 20 | Format-Table TimeCreated, Id, Message -AutoSize</code></pre> <p>Event ID 4625 indicates a failed account logon. Use this to detect brute-force attempts.</p> <li> <strong>Generate a System Report:</strong> In CMD:</li> <pre><code class="language-bash">
systeminfo > C:\Reports\SystemReport.txt</code></pre> <p>In PowerShell:</p> <pre><code class="language-powershell">
Get-ComputerInfo | Out-File C:\Reports\SystemReport.txt</code></pre> <p>This outputs OS version, patch level, BIOS, memory, and more—essential for audits or documenting server builds.</p> </ul>

        ```
        <h4>Automating Tasks with Batch &amp; PowerShell Scripts</h4>
        <ul>
            <li>
                <strong>Concept:</strong> Batch files (<code>.bat</code>) and PowerShell scripts (<code>.ps1</code>) let you automate sequences of commands. A shebang is not required, but scripts must be saved with the correct extension and, in the case of PowerShell, you may need to adjust <code>ExecutionPolicy</code>.
            </li>
            <li>
                <strong>When to Use:</strong> For repeated tasks—backups, log rotation, system health checks—scripts reduce manual effort and ensure consistency.
            </li>
            <li>
                <strong>Simple Batch Script (backup.bat):</strong></li>
            <pre><code class="language-bash">
```

@echo off
rem Create backup folder with date
set BACKUPDIR=C:\Backups%DATE:\~10,4%-%DATE:\~4,2%-%DATE:\~7,2%
mkdir "%BACKUPDIR%"
xcopy "C:\Projects" "%BACKUPDIR%\Projects" /E /I /Y
echo Backup completed at %TIME%
pause</code></pre> <p>The above script:</p> <ul> <li>Turns echo off for cleaner output.</li> <li>Sets <code>BACKUPDIR</code> to <code>C:\Backups\YYYY-MM-DD</code> using substring of <code>%DATE%</code>.</li> <li>Creates the backup directory.</li> <li>Uses <code>xcopy</code> to copy <code>C:\Projects</code> recursively to the backup folder.</li> <li>Echoes completion time and pauses so you can read the results.</li> </ul> <li> <strong>PowerShell Backup Script (backup.ps1):</strong></li> <pre><code class="language-powershell">

# Forces script to run even if policy is restrictive

Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass -Force

\$today = Get-Date -Format "yyyy-MM-dd"
\$backupDir = "C:\Backups\$today"
if (-Not (Test-Path \$backupDir)) { New-Item -Path \$backupDir -ItemType Directory }

robocopy "C:\Projects" "\$backupDir\Projects" /MIR /Z /R:3 /W:5

Write-Host "Backup completed at \$(Get-Date -Format "HH\:mm\:ss")" </code></pre> <p>Key points:</p> <ul> <li>Temporarily bypasses execution policy so the script can run.</li> <li>Calculates today’s date in <code>yyyy-MM-dd</code> format.</li> <li>Creates backup directory if it doesn’t exist.</li> <li>Uses <code>robocopy</code> to mirror (<code>/MIR</code>) the <code>C:\Projects</code> folder, with restartable mode (<code>/Z</code>) and retry logic (<code>/R:3</code>, <code>/W:5</code>).</li> <li>Echoes a timestamp on completion.</li> </ul> <p>Save this as <code>backup.ps1</code> and schedule it in Task Scheduler to run nightly—no manual intervention necessary.</p> </ul>

        ```
        <h4>Mounting VHD and ISO Images</h4>
        <ul>
            <li>
                <strong>Concept:</strong> Virtual Hard Disks (<code>.vhd</code>, <code>.vhdx</code>) and ISO images (<code>.iso</code>) can be mounted to appear as local drives. This is useful for inspections, installations, or testing without burning to physical media.
            </li>
            <li>
                <strong>When to Use:</strong> When dealing with virtual machine images, backups, or installer ISOs, mounting saves time compared to GUI steps.
            </li>
            <li>
                <strong>Mount an ISO:</strong> In PowerShell:</li>
            <pre><code class="language-powershell">
```

Mount-DiskImage -ImagePath "C:\ISO\Windows10.iso"</code></pre> <p>After mounting, the ISO appears as a new drive letter in File Explorer and CLI. To unmount:</p> <pre><code class="language-powershell">
Dismount-DiskImage -ImagePath "C:\ISO\Windows10.iso"</code></pre> <li> <strong>Mount a VHD:</strong> In PowerShell (elevated shell):</li> <pre><code class="language-powershell">
Mount-DiskImage -ImagePath "C:\VMs\Ubuntu.vhdx"</code></pre> <p>To list mounted images:</p> <pre><code class="language-powershell">
Get-DiskImage | Where-Object { $\_.Attached -eq \$true }</code></pre> <p>To detach:</p> <pre><code class="language-powershell">
Dismount-DiskImage -ImagePath "C:\VMs\Ubuntu.vhdx"</code></pre> </ul>

        ```
        <h4>Network Shares and Remote File Systems</h4>
        <ul>
            <li>
                <strong>Concept:</strong> Windows can mount SMB/CIFS shares and NFS shares (if enabled) directly as drives or network paths. This lets you navigate remote file systems as if they were local.
            </li>
            <li>
                <strong>When to Use:</strong> Share files between team members, access a company NAS, or back up data to a remote server without copying locally first.
            </li>
            <li>
                <strong>Map a Network Share as a Drive:</strong> In CMD or PowerShell:</li>
            <pre><code class="language-bash">
```

net use X: \NAS\Shared /persistent\:yes</code></pre> <p>This maps the SMB share <code>\NAS\Shared</code> to drive <code>X:</code>. It reconnects on login if <code>/persistent\:yes</code> is used. To disconnect:</p> <pre><code class="language-bash">
net use X: /delete</code></pre> <li> <strong>Mount NFS Share (if Client for NFS is installed):</strong> In PowerShell:</li> <pre><code class="language-powershell">
New-PSDrive -Name N -PSProvider FileSystem -Root "\nfsserver\export" -Persist</code></pre> <p>This mounts the NFS export to drive letter <code>N:</code>. To remove:</p> <pre><code class="language-powershell">
Remove-PSDrive -Name N</code></pre> </ul>

        ```
        <h4>File Association and Opening GUI Apps</h4>
        <ul>
            <li>
                <strong>Concept:</strong> Sometimes you need to switch from CLI to GUI—opening files in Notepad, launching Word documents, or previewing images. The <code>start</code> command (CMD &amp; PowerShell) does the trick.
            </li>
            <li>
                <strong>When to Use:</strong> After editing a config file in CLI, open it in Notepad. Open a URL in the default browser from a script. Launch PowerPoint to review a slide deck without navigating through File Explorer.
            </li>
            <li>
                <strong>Open a File in Default App:</strong></li>
            <pre><code class="language-bash">
```

start C:\Users\YourName\Documents\notes.txt</code></pre> <p>This opens <code>notes.txt</code> in the default text editor (Notepad or VS Code if you’ve associated it).</p> <li> <strong>Open a File in a Specific App:</strong></li> <pre><code class="language-bash">
start "" "C:\Program Files\Notepad++\notepad++.exe" "C:\Users\YourName\Documents\notes.txt"</code></pre> <p>The empty quotes after <code>start</code> accommodate window title, then the path to the executable and file.</p> <li> <strong>Open a URL in Browser:</strong></li> <pre><code class="language-bash">
start [https://cap10.tech](https://cap10.tech)</code></pre> </ul>

        ```
        <h4>Environment Variables in Action</h4>
        <ul>
            <li>
                <strong>Concept:</strong> Environment variables stored in <code>%PATH%</code> let you run executables from any directory. Use <code>[Environment]::GetEnvironmentVariable</code> in PowerShell to inspect or modify them in scripts.
            </li>
            <li>
                <strong>When to Use:</strong> When installing tools like Git, Python, or custom scripts in <code>C:\Scripts</code>, update <code>PATH</code> so you can run them without typing full paths.
            </li>
            <li>
                <strong>View PATH:</strong> In CMD:</li>
            <pre><code class="language-bash">
```

echo %PATH%</code></pre> <p>In PowerShell:</p> <pre><code class="language-powershell">
\$Env\:PATH</code></pre> <li> <strong>Add a Directory to PATH (for Current Session):</strong> In PowerShell:</li> <pre><code class="language-powershell">
\$Env\:PATH = "\$Env\:PATH;C:\Scripts"</code></pre> <p>This adds <code>C:\Scripts</code> to the path for this session. To set it permanently:</p> <pre><code class="language-powershell">
\[Environment]::SetEnvironmentVariable("PATH", \$Env\:PATH + ";C:\Scripts", "User")</code></pre> <p>This modifies the user’s environment variable. Log out and back in (or restart PowerShell) to see changes.</p> </ul>

        ```
        <h4>Disk Cleanup and Temp File Management</h4>
        <ul>
            <li>
                <strong>Concept:</strong> Temporary files accumulate over time—browser caches, installer leftovers, application logs. Removing them frees disk space and may improve performance.
            </li>
            <li>
                <strong>When to Use:</strong> When disk usage creeps above 90%, or before creating backups to avoid archiving unnecessary files.
            </li>
            <li>
                <strong>Clean Up Temp Folder:</strong> In CMD or PowerShell:</li>
            <pre><code class="language-bash">
```

del /q /f "%TEMP%\*"    # Delete all files in TEMP, quietly and forcefully
for /d %i in ("%TEMP%\*") do @rmdir /s /q "%i"   # Delete all subdirectories in TEMP</code></pre> <p>In PowerShell, a single command:</p> <pre><code class="language-powershell">
Remove-Item "\$Env\:TEMP\*" -Recurse -Force</code></pre> <li> <strong>Disk Cleanup Utility (CLI):</strong> Invoke Disk Cleanup to remove system temp files, Recycle Bin contents, Windows Update cleanup:</li> <pre><code class="language-bash">
cleanmgr /sageset:1
cleanmgr /sagerun:1</code></pre> <p><code>/sageset:1</code> displays GUI to configure cleanup options once. <code>/sagerun:1\</code runs those options silently thereafter. Automate this via Task Scheduler for monthly cleanup.</p> </ul>

        ```
        <h4>Group Policy and Scripted File System Settings</h4>
        <ul>
            <li>
                <strong>Concept:</strong> In domain environments, Group Policy controls file system behaviors—redirected folders, security settings. Use <code>gpupdate</code> and <code>gpresult</code> in CLI to manage and diagnose policy application.
            </li>
            <li>
                <strong>When to Use:</strong> When you need to enforce folder redirection (e.g., Documents to a network share), prevent users from accessing local drives, or deploy scripts at login.
            </li>
            <li>
                <strong>Force Group Policy Update:</strong> In CMD or PowerShell:</li>
            <pre><code class="language-bash">
```

gpupdate /force</code></pre> <li> <strong>View Applied Policies:</strong></li> <pre><code class="language-bash">
gpresult /r</code></pre> <p>Use <code>/Scope User</code> or <code>/Scope Computer</code> to narrow results. Output logs where scripts executed or file redirections configured, helping troubleshoot environment issues.</p> </ul>

        ```
        <h4>Useful Keyboard Shortcuts and Shell Tricks</h4>
        <ul>
            <li>
                <strong>Tab Completion</strong>
                <p><em>Concept:</em> Instead of typing full file or folder names, press <kbd>Tab</kbd> to autocomplete. In CMD, press multiple times to cycle through matches. In PowerShell, press <kbd>Tab</kbd> once for the best match.</p>
                <p><em>When to Use:</em> When navigating deep folder structures (<code>cd C:\Progra</code> then <kbd>Tab</kbd> completes to <code>cd C:\Program Files\</code>).</p>
            </li>
            <li>
                <strong>Ctrl + C</strong>
                <p><em>Concept:</em> Cancels the current command or script. In PowerShell, it stops the running process; in CMD, it stops the command and returns to prompt.</p>
                <p><em>When to Use:</em> If you accidentally run a command that takes too long (<code>ping -t localhost</code> pings indefinitely until you press <kbd>Ctrl + C</kbd>).</p>
            </li>
            <li>
                <strong>Arrow Keys</strong>
                <p><em>Concept:</em> Use up/down arrows to scroll through command history. Left/right arrows move the cursor within the current command line. In PowerShell, <code>Ctrl + R</code> invokes reverse search.</p>
                <p><em>When to Use:</em> When you need to rerun or edit a recent command without retyping everything.</p>
            </li>
            <li>
                <strong>F2 / F3</strong>
                <p><em>Concept:</em> In CMD, <kbd>F2</kbd> copies characters from the previous command up to a specified character; <kbd>F3</kbd> pastes the entire previous command. In PowerShell, these keys behave like arrow keys by default.</p>
                <p><em>When to Use:</em> When editing a long command in CMD: press <kbd>F2</kbd>, type a character to copy up to that point; press <kbd>F3</kbd> to cycle commands matching the prefix.</p>
            </li>
            <li>
                <strong>Ctrl + L (PowerShell)</strong>
                <p><em>Concept:</em> Clears the console window—same as <code>Clear-Host</code> (<code>cls</code>). CMD uses <code>cls</code> by default.</p>
                <p><em>When to Use:</em> Wipe clutter from your session to focus on new output.</p>
            </li>
        </ul>

        <h4>GUI-CLI Hybrid Tools</h4>
        <ul>
            <li>
                <strong>RoboCopy GUI</strong>
                <p><em>Concept:</em> Although <code>robocopy</code> is a CLI tool, you can use third-party GUIs (e.g., RoboCop, RoboMirror) to build <code>robocopy</code> commands visually and then copy the resulting script to use in PowerShell or CMD.</p>
                <p><em>When to Use:</em> When you need robust directory synchronization with complex filters but prefer visual configuration.</p>
            </li>
            <li>
                <strong>Sysinternals Suite</strong>
                <p><em>Concept:</em> Sysinternals offers CLI utilities like <code>du.exe</code> (disk usage), <code>handle.exe</code> (list open file handles), and <code>alias</code> for process debugging. Add the Sysinternals folder to <code>%PATH%</code> so you can run these tools from any location.</p>
                <p><em>When to Use:</em> When you need low-level inspection—find which process holds a lock on a file (<code>handle filename</code>), or monitor real-time disk usage (<code>du</code>).</p>
            </li>
            <li>
                <strong>fzf (Fuzzy Finder)</strong>
                <p><em>Concept:</em> The cross-platform <code>fzf</code> utility can be installed via Chocolatey (<code>choco install fzf</code>). It provides fuzzy search in CMD and PowerShell, letting you filter file names or history entries by typing approximate matches.</p>
                <p><em>When to Use:</em> When you have hundreds of files or very long command history and want to quickly narrow down options.</p>
            </li>
        </ul>

        <h4>Tracking Changes Over Time</h4>
        <ul>
            <li>
                <strong>Concept:</strong> Use Git in the command line to track revisions of code, text files, or even configuration files. PowerShell’s <code>Set-PSReadLineOption -HistorySaveStyle SaveAtExit</code> ensures your session history is preserved between restarts.
            </li>
            <li>
                <strong>When to Use:</strong> When you need an audit trail of changes—scripts you wrote, config files you edited, or project files that evolved over time.
            </li>
            <li>
                <strong>Git Init a Folder:</strong></li>
            <pre><code class="language-bash">
```

cd C:\Projects\NewProject
git init </code></pre> <p>This creates a <code>.git</code> folder. Add files, then <code>git commit</code> to snapshot changes:</p> <pre><code class="language-bash">
git add .
git commit -m "Initial commit"</code></pre> <li> <strong>PowerShell History Persistence:</strong> Add to your profile:</li> <pre><code class="language-powershell">
Set-PSReadLineOption -HistorySaveStyle SaveAtExit
Set-PSReadLineOption -HistorySearchCursorMovesToEnd</code></pre> <p>This ensures every command you run is appended to <code>%USERPROFILE%\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost\_history.txt</code>. Next time you open PowerShell, your history is intact—track what you did yesterday or last week.</p> </ul>

        ```
        <h4>Sandboxing, Quarantine Flags &amp; Execution Policy</h4>
        <ul>
            <li>
                <strong>Concept:</strong> PowerShell’s <code>ExecutionPolicy</code> prevents running untrusted scripts. Quarantine flags on downloaded files may block execution until you clear them. Always verify script sources before bypassing policies.
            </li>
            <li>
                <strong>When to Use:</strong> When running a script downloaded from the internet, or automating environments that require running custom modules and scripts.
            </li>
            <li>
                <strong>Check Execution Policy:</strong> In PowerShell:</li>
            <pre><code class="language-powershell">
```

Get-ExecutionPolicy -List</code></pre> <p>By default, local scripts may be blocked. To run a script just once, bypass policy:</p> <pre><code class="language-powershell">
powershell -ExecutionPolicy Bypass -File .\deploy.ps1</code></pre> <li> <strong>Remove Quarantine Flag:</strong> Windows tags downloaded files with <code>Zone.Identifier</code> to block unknown sources. To remove:</li> <pre><code class="language-powershell">
Unblock-File -Path .\downloadedScript.ps1</code></pre> <p>Now the file is not considered “blocked” and can run under your current execution policy.</p> </ul>

        ```
        <p>By grounding each command in scenarios—permissions and ACLs, symlinks, disk usage analysis, network shares, scripting, and security—you not only know which commands to run but also when and why. Practice these techniques to build confidence. Sail on, captain—your mastery of Windows’ command line grows with every command!</p>
    </section>
</main>

<footer class="highlight-box">
    <p>&copy; 2025 cap10bill. All rights reserved.</p>
</footer>
<script type="module" src="blog.js"></script>

</body>
</html>
